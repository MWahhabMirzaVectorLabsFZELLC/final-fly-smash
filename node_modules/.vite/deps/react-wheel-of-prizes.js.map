{
  "version": 3,
  "sources": ["../../react-wheel-of-prizes/src/index.js"],
  "sourcesContent": ["import React, { useEffect, useState } from 'react'\n\nconst WheelComponent = ({\n  segments,\n  segColors,\n  winningSegment,\n  onFinished,\n  primaryColor,\n  contrastColor,\n  buttonText,\n  isOnlyOnce = true,\n  size = 290,\n  upDuration = 100,\n  downDuration = 1000\n}) => {\n  let currentSegment = ''\n  let isStarted = false\n  const [isFinished, setFinished] = useState(false)\n  let timerHandle = 0\n  const timerDelay = segments.length\n  let angleCurrent = 0\n  let angleDelta = 0\n  let canvasContext = null\n  let maxSpeed = Math.PI / `${segments.length}`\n  const upTime = segments.length * upDuration\n  const downTime = segments.length * downDuration\n  let spinStart = 0\n  let frames = 0\n  const centerX = 300\n  const centerY = 300\n  useEffect(() => {\n    wheelInit()\n    setTimeout(() => {\n      window.scrollTo(0, 1)\n    }, 0)\n  }, [])\n  const wheelInit = () => {\n    initCanvas()\n    wheelDraw()\n  }\n\n  const initCanvas = () => {\n    let canvas = document.getElementById('canvas')\n    if (navigator.appVersion.indexOf('MSIE') !== -1) {\n      canvas = document.createElement('canvas')\n      canvas.setAttribute('width', 1000)\n      canvas.setAttribute('height', 600)\n      canvas.setAttribute('id', 'canvas')\n      document.getElementById('wheel').appendChild(canvas)\n    }\n    canvas.addEventListener('click', spin, false)\n    canvasContext = canvas.getContext('2d')\n  }\n  const spin = () => {\n    isStarted = true\n    if (timerHandle === 0) {\n      spinStart = new Date().getTime()\n      // maxSpeed = Math.PI / ((segments.length*2) + Math.random())\n      maxSpeed = Math.PI / segments.length\n      frames = 0\n      timerHandle = setInterval(onTimerTick, timerDelay)\n    }\n  }\n  const onTimerTick = () => {\n    frames++\n    draw()\n    const duration = new Date().getTime() - spinStart\n    let progress = 0\n    let finished = false\n    if (duration < upTime) {\n      progress = duration / upTime\n      angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2)\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / upTime\n          angleDelta =\n            maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2)\n          progress = 1\n        } else {\n          progress = duration / downTime\n          angleDelta =\n            maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2)\n        }\n      } else {\n        progress = duration / downTime\n        angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2)\n      }\n      if (progress >= 1) finished = true\n    }\n\n    angleCurrent += angleDelta\n    while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2\n    if (finished) {\n      setFinished(true)\n      onFinished(currentSegment)\n      clearInterval(timerHandle)\n      timerHandle = 0\n      angleDelta = 0\n    }\n  }\n\n  const wheelDraw = () => {\n    clear()\n    drawWheel()\n    drawNeedle()\n  }\n\n  const draw = () => {\n    clear()\n    drawWheel()\n    drawNeedle()\n  }\n\n  const drawSegment = (key, lastAngle, angle) => {\n    const ctx = canvasContext\n    const value = segments[key]\n    ctx.save()\n    ctx.beginPath()\n    ctx.moveTo(centerX, centerY)\n    ctx.arc(centerX, centerY, size, lastAngle, angle, false)\n    ctx.lineTo(centerX, centerY)\n    ctx.closePath()\n    ctx.fillStyle = segColors[key]\n    ctx.fill()\n    ctx.stroke()\n    ctx.save()\n    ctx.translate(centerX, centerY)\n    ctx.rotate((lastAngle + angle) / 2)\n    ctx.fillStyle = contrastColor || 'white'\n    ctx.font = 'bold 1em proxima-nova'\n    ctx.fillText(value.substr(0, 21), size / 2 + 20, 0)\n    ctx.restore()\n  }\n\n  const drawWheel = () => {\n    const ctx = canvasContext\n    let lastAngle = angleCurrent\n    const len = segments.length\n    const PI2 = Math.PI * 2\n    ctx.lineWidth = 1\n    ctx.strokeStyle = primaryColor || 'black'\n    ctx.textBaseline = 'middle'\n    ctx.textAlign = 'center'\n    ctx.font = '1em proxima-nova'\n    for (let i = 1; i <= len; i++) {\n      const angle = PI2 * (i / len) + angleCurrent\n      drawSegment(i - 1, lastAngle, angle)\n      lastAngle = angle\n    }\n\n    // Draw a center circle\n    ctx.beginPath()\n    ctx.arc(centerX, centerY, 50, 0, PI2, false)\n    ctx.closePath()\n    ctx.fillStyle = primaryColor || 'black'\n    ctx.lineWidth = 10\n    ctx.strokeStyle = contrastColor || 'white'\n    ctx.fill()\n    ctx.font = 'bold 1em proxima-nova'\n    ctx.fillStyle = contrastColor || 'white'\n    ctx.textAlign = 'center'\n    ctx.fillText(buttonText || 'Spin', centerX, centerY + 3)\n    ctx.stroke()\n\n    // Draw outer circle\n    ctx.beginPath()\n    ctx.arc(centerX, centerY, size, 0, PI2, false)\n    ctx.closePath()\n\n    ctx.lineWidth = 10\n    ctx.strokeStyle = primaryColor || 'black'\n    ctx.stroke()\n  }\n\n  const drawNeedle = () => {\n    const ctx = canvasContext\n    ctx.lineWidth = 1\n    ctx.strokeStyle = contrastColor || 'white'\n    ctx.fileStyle = contrastColor || 'white'\n    ctx.beginPath()\n    ctx.moveTo(centerX + 20, centerY - 50)\n    ctx.lineTo(centerX - 20, centerY - 50)\n    ctx.lineTo(centerX, centerY - 70)\n    ctx.closePath()\n    ctx.fill()\n    const change = angleCurrent + Math.PI / 2\n    let i =\n      segments.length -\n      Math.floor((change / (Math.PI * 2)) * segments.length) -\n      1\n    if (i < 0) i = i + segments.length\n    ctx.textAlign = 'center'\n    ctx.textBaseline = 'middle'\n    ctx.fillStyle = primaryColor || 'black'\n    ctx.font = 'bold 1.5em proxima-nova'\n    currentSegment = segments[i]\n    isStarted && ctx.fillText(currentSegment, centerX + 10, centerY + size + 50)\n  }\n  const clear = () => {\n    const ctx = canvasContext\n    ctx.clearRect(0, 0, 1000, 800)\n  }\n  return (\n    <div id='wheel'>\n      <canvas\n        id='canvas'\n        width='1000'\n        height='800'\n        style={{\n          pointerEvents: isFinished && isOnlyOnce ? 'none' : 'auto'\n        }}\n      />\n    </div>\n  )\n}\nexport default WheelComponent\n"],
  "mappings": "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",
  "names": ["WheelComponent", "segments", "segColors", "winningSegment", "onFinished", "primaryColor", "contrastColor", "buttonText", "isOnlyOnce", "size", "upDuration", "downDuration", "currentSegment", "isStarted", "useState", "isFinished", "setFinished", "timerHandle", "timerDelay", "length", "angleCurrent", "angleDelta", "canvasContext", "maxSpeed", "Math", "PI", "upTime", "downTime", "spinStart", "frames", "centerX", "centerY", "useEffect", "wheelInit", "setTimeout", "window", "scrollTo", "initCanvas", "wheelDraw", "canvas", "document", "getElementById", "navigator", "appVersion", "indexOf", "createElement", "setAttribute", "appendChild", "addEventListener", "spin", "getContext", "Date", "getTime", "setInterval", "onTimerTick", "draw", "duration", "progress", "finished", "sin", "clearInterval", "clear", "drawWheel", "drawNeedle", "drawSegment", "key", "lastAngle", "angle", "ctx", "value", "save", "beginPath", "moveTo", "arc", "lineTo", "closePath", "fillStyle", "fill", "stroke", "translate", "rotate", "font", "fillText", "substr", "restore", "len", "PI2", "lineWidth", "strokeStyle", "textBaseline", "textAlign", "i", "fileStyle", "change", "floor", "clearRect", "React", "pointerEvents"]
}
